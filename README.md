# Реализация ключевых алгоритмов для игры "Heroes Battle"

Этот проект содержит реализации четырех основных алгоритмов, которые используются в пошаговой стратегической игре "Heroes Battle". Каждый алгоритм решает специфическую задачу, от генерации армии до поиска пути на поле боя.

## Описание реализованных алгоритмов

### 1. GeneratePresetImpl (Генерация армии)

#### Описание алгоритма
Этот модуль отвечает за создание армии противника в рамках заданных ограничений. Был реализован **жадный алгоритм**, который показал себя наиболее эффективным для данной задачи.

1.  **Сортировка:** Сначала все доступные типы юнитов сортируются в порядке убывания их эффективности. Эффективность рассчитывается по двум критериям:
    *  Основной критерий: соотношение `атака / стоимость`.
    *  Дополнительный критерий (при равенстве основного): соотношение `здоровье / стоимость`.
2.  **Наполнение армии:** После сортировки армия итеративно наполняется самыми эффективными юнитами. Добавление юнитов одного типа прекращается при достижении одного из лимитов:
    *   Общая стоимость армии превышает `maxPoints`.
    *   Количество юнитов данного типа достигает 11.

#### Анализ сложности
- **Сложность: O(N log N + M)**

Обоснование:
- `N` — количество **типов** юнитов (в данном случае, `N=4`, что является константой).
- `M` — итоговое количество юнитов в созданной армии.

Сложность складывается из двух частей:
1.  `O(N log N)` на первоначальную сортировку `N` типов юнитов.
2.  `O(M)` на итеративное наполнение армии, так как для добавления каждого из `M` юнитов выполняется константное число операций.

Поскольку `N` — очень малое число, доминирующей частью является `O(M)`, что делает алгоритм практически линейным относительно размера итоговой армии. Это значительно эффективнее, чем `O(N * maxPoints)`, который потребовался бы для решения задачи о рюкзаке методом динамического программирования.

---

### 2. SimulateBattleImpl (Симуляция боя)

#### Описание алгоритма
Модуль симулирует пошаговый бой между двумя армиями.

Логика симуляции построена на раундах:
1.  **Формирование общего списка:** В начале каждого раунда все живые юниты обеих армий собираются в **один общий список**.
2.  **Определение порядка хода:** Этот список сортируется по убыванию показателя атаки, создавая единую очередь ходов для всех юнитов на поле.
3.  **Ходы:** Алгоритм итерирует по отсортированному списку, и каждый юнит совершает атаку. Чтобы юниты, убитые в текущем раунде, не смогли сделать ход, их ID добавляются во временный список убитых.
4.  **Завершение раунда:** Раунд заканчивается, когда все юниты совершили свой ход. Бой завершается полностью, когда в одной из армий не остается живых юнитов.

#### Анализ сложности
- **Сложность: O(R * n log n)**, в худшем случае **O(n² * log n)**

Обоснование:
- `n` — общее количество юнитов в обеих армиях в начале боя.
- `R` — количество раундов в бою.

Сложность одного раунда определяется операцией сортировки юнитов, которая составляет `O(n log n)`. В худшем сценарии, когда за раунд погибает только один юнит, количество раундов `R` может достигать `n`. Таким образом, общая сложность в худшем случае составляет `O(n * (n log n)) = O(n² * log n)`, что соответствует требованиям.

---

### 3. SuitableForAttackUnitsFinderImpl (Поиск целей для атаки)

#### Описание алгоритма
Этот модуль определяет список юнитов, доступных для атаки.

Алгоритм работает следующим образом:
1.  **Интерпретация входных данных:** Входной параметр `List<List<Unit>> unitsByRow` рассматривается как список **колонок** (вертикалей), а не строк.
2.  **Проверка по колонкам:** Для каждой колонки создается `Set` с Y-координатами всех живых юнитов в ней.
3.  **Определение цели:** Для каждого юнита в колонке выполняется проверка:
    *   При атаке на **левую армию** (армию компьютера) юнит считается целью, если в его колонке **под ним** (`y+1`) нет другого юнита.
    *   При атаке на **правую армию** (армию игрока) юнит считается целью, если в его колонке **над ним** (`y-1`) нет другого юнита.

#### Анализ сложности
- **Сложность: O(n)**

Обоснование:
- `n` — общее число юнитов в армии противника.

Алгоритм за один проход по всем юнитам `n` распределяет их по колонкам и внутри каждой колонки выполняет проверку за константное время (благодаря `HashSet`). Таким образом, итоговая сложность остается линейной, `O(n)`, что полностью соответствует требованиям.

---

### 4. UnitTargetPathFinderImpl (Поиск кратчайшего пути)

#### Описание алгоритма
Для поиска кратчайшего пути между двумя юнитами на поле боя используется **алгоритм A***.

1.  **Карта:** Игровое поле представляется в виде графа, где каждая клетка — это вершина.
2.  **Препятствия:** Все остальные юниты на поле считаются непроходимыми препятствиями.
3.  **Эвристика:** В качестве эвристической функции для A* используется **Евклидово расстояние**, так как оно является допустимым и консистентным для поля, где возможно движение по диагонали (8 направлений).
4.  **Результат:** Алгоритм возвращает список клеток (объектов `Edge`), составляющих кратчайший путь, либо пустой список, если путь не найден.

#### Анализ сложности
- **Сложность: O((W * H) * log(W * H))**

Обоснование:
- `W` и `H` — ширина и высота игрового поля.
- Общее число вершин в графе `V = W * H`.

Сложность алгоритма A* при использовании приоритетной очереди (бинарной кучи) составляет `O(V * log V)`. Каждая операция с очередью (добавление или извлечение) стоит `O(log V)`, и в худшем случае алгоритм может посетить каждую вершину графа.

Таким образом, сложность составляет `O((W * H) * log(W * H))`, что соответствует требованиям.
